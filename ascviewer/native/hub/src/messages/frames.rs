#![allow(unused_imports)]

use crate::tokio;
use prost::Message;
use rinf::send_rust_signal;
use rinf::DartSignal;
use rinf::SharedCell;
use std::cell::RefCell;
use std::sync::Mutex;
use std::sync::OnceLock;
use tokio::sync::mpsc::channel;
use tokio::sync::mpsc::Receiver;
use tokio::sync::mpsc::Sender;

// @generated
// This file is @generated by prost-build.
/// \[RINF:DART-SIGNAL\]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FramesReq {
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signal {
    #[prost(string, tag="1")]
    pub sig_name: ::prost::alloc::string::String,
    #[prost(string, tag="2")]
    pub sig_value: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FrameItem {
    #[prost(int32, tag="1")]
    pub msg_id: i32,
    #[prost(string, tag="2")]
    pub msg_name: ::prost::alloc::string::String,
    #[prost(string, tag="3")]
    pub direction: ::prost::alloc::string::String,
    #[prost(message, repeated, tag="4")]
    pub signals: ::prost::alloc::vec::Vec<Signal>,
}
/// \[RINF:RUST-SIGNAL\]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FramesResp {
    #[prost(message, repeated, tag="1")]
    pub frames: ::prost::alloc::vec::Vec<FrameItem>,
}
// @@protoc_insertion_point(module)

type FramesReqCell = SharedCell<(
    Option<Sender<DartSignal<FramesReq>>>,
    Option<Receiver<DartSignal<FramesReq>>>,
)>;
pub static FRAMES_REQ_CHANNEL: FramesReqCell =
    OnceLock::new();

impl FramesReq {
    pub fn get_dart_signal_receiver() -> Receiver<DartSignal<Self>> {
        let cell = FRAMES_REQ_CHANNEL
            .get_or_init(|| {
                let (sender, receiver) = channel(1024);
                Mutex::new(RefCell::new(Some((Some(sender), Some(receiver)))))
            })
            .lock()
            .unwrap();
        #[cfg(debug_assertions)]
        {
            // After Dart's hot restart,
            // a sender from the previous run already exists
            // which is now closed.
            let borrowed = cell.borrow();
            let pair = borrowed.as_ref().unwrap();
            let is_closed = pair.0.as_ref().unwrap().is_closed();
            drop(borrowed);
            if is_closed {
                let (sender, receiver) = channel(1024);
                cell.replace(Some((Some(sender), Some(receiver))));
            }
        }
        let pair = cell.take().unwrap();
        cell.replace(Some((pair.0, None)));
        pair.1.expect("A receiver can be taken only once")
    }
}

impl FramesResp {
    pub fn send_signal_to_dart(&self) {
        send_rust_signal(
            3,
            self.encode_to_vec(),
            Vec::new(),
        );
    }
}
